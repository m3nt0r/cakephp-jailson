h1. Jailson for CakePHP

A simple but highly flexible access control plugin with a human interface.

h2. About the system

The system is inspired (well, almost a port) of ACLatraz from Kriss Kowalik (github). I discovered 
it while i was looking into Ruby/Padrino. I've read the readme and was blown away. But since
i'm more a PHP guy i simply had to implement it with my app, one way or another. Born was Jailson.

The plugin is basicly a Behavior which you throw at your User model. From there on out you can 
use a bunch of short methods to group users and map them onto ressources (other models).

Speaking of mapping: this is still just for access control. It wont give you any information
about the model data. Just if there's an existing connection, or not. 

h2. Basic Syntax

I will skip the install text for now, and get to straight to it. 

Let's assume we have two Objects. One is our User and one is something that needs some control.

<pre>
<code>
  $this->User->id = '4c8b8d63-9ed4-449a-afe7-a7a6e9f4bebc';
  $this->Project->id = '4c92dc36-c078-43f8-b8a8-89f2e9f4bebc';
</code>
</pre>

h3. Talking Jailson

Now, to make the (current) user the owner of the project model:

<pre>
<code>
  $this->User->lockAs('admin_of', $this->Project);
</code>
</pre>

Simple, isn't it? And to verify that info at any point.

<pre>
<code>
  $this->User->is('admin_of', $this->Project); // true
  $this->User->isNot('admin_of', $this->Project); // false
</code>
</pre>

The juice here is that the model objects have their id property set. I use 
this info to make the connection and store the relationship.

(well, you may omit it for this->Project, but i'll describe that later)

h3. Working with arrays

You can also assign multiple roles in one line.

<pre>
<code>
  $this->User->lockAs(array('admin', 'member', 'reporter'), $this->Project);
</code>
</pre>

And you can test multiple roles in one line. 

<pre>
<code>
  $this->User->is(array('member', 'reporter'), $this->Project); // true
  $this->User->is(array('member', 'reporter', 'watcher'), $this->Project); // false
  $this->User->is(array('member', 'reporter', 'admin'), $this->Project); // true
</code>
</pre>

h3. The logic switch

You can skip the "lockAs" command, if you want, and just make it happen.

<pre>
<code>
  $this->User->is('watcher_of', $this->Project, true); // where 'true' means: Create
</code>
</pre>

The opposite is also possible, using the "isNot" command

<pre>
<code>
  $this->User->isNot('watcher_of', $this->Project, true); // where 'true' means: Delete
</code>
</pre>

h3. The simple stuff

Above i've showed how you can relate someone to something. But what about simple role based grouping?

<pre>
<code>
  $this->User->lockAs('client'); // .. easy
      // or
  $this->User->is('client', true);
</code>
</pre>

Finally we want to delete stuff. Since we're talking Jailson there's a obvious command for that.

<pre>
<code>
  $this->User->release('client');
</code>
</pre>


h2. Who said we need Objects?

Well, initially, i did.. What i liked most about ACLatraz was that you can just provide a object
to setup the connection. But there may be cases where we just want to store a sublevel with a role. 
Therefore Jailson allows locking users to simple strings. 

<pre>
<code>
  $this->User->lockAs('ninja_at', 'cakephp'); // .. or whatever you want
</code>
</pre>

As a sidenote below the first example i emphasized the importance of the Model.id when working with objects.
That is true for the User model, but not for the assigned model. Internally Jailson will figure out if or 
if not the passed object has an id. If not, it will just use the model name to create the connection.

That would be the equivalent of writing:

<pre>
<code>
  $this->User->lockAs('member', 'Project');
</code>
</pre>


h2. The Semantics, or Why i really like this

You might have noticed that i am no using the intial role name at some points. Instead i am using "_at" or "_of"
in the code. This still yields to the initial role as this underscore suffix is removed internally and has the
sole purpose of making code more readable. You can embrace or omit. It's up to you.

Here's a list of accepted suffixes with examples:

* @_of@ example: @member_of@
* @_at@ example: @located_at@
* @_on@ example: @based_on@
* @_by@ example: @referred_by@
* @_for@ example: @responsible_for@
* @_in@ example: @seen_in@

Should give you some ideas on how to chain stuff.


h2. Working with AuthComponent

I chose a tight integration with the core component to make this whole thing pretty solid and versatile. 
In the current implementation you won't need to configure anything if you already using the AuthComponent.

h3. The Jailson ACL Component

Once loaded it will auto configure the AuthComponent to work with it's very own version of isAuthorized(). 
Thanks to all the options in Auth this is pretty straight forward. It will register itself as isAuthorized 
handler object and leave everything else alone.

Because i don't want to write is/isNot all the time (even though it makes code more readable), we can now
set the whole access setup in the @Controller::$components@ array. Yes, even on AppController level.

<pre>
<code>
  public $components = array(
		'Jailson.AclAuth' => array(
			'allow' => array(
				'index' => array(
					'ninja',
					'ninja' => array('killer'),
					array('samurai', 'warrior'),
				)	
			)
		)
  );
</code>
</pre>

Okay.. the examples are not really real-world but i wanted to show all possible ways to define access.

Lets go line by line:

* @'ninja'@ - The currently logged in user needs to be lockedAs "ninja" to gain access.
* @'ninja' => array('killer')@ - Or, apart from being "ninja", must be sentenced as "killer"

The system will try each rule top to bottom and stop on the first allowed and grant the access.
You can look at it as a "OR" condition with an optional sublevel.

  "Current user can access index action if ninja or ninja-killer"

h3. The simple array with no key.

In all previous examples it was just one role per line that has to match. We can break this by
mixing in a simple array with a list of roles that all have to match.

* @array('samurai', 'warrior')@ - The user must play ALL of these roles to get access.

There we have our "AND" condition (so to speak).


h2. Current state

As this cake is still hot i wanna take some time to review the source and finetune the API.
I am also planning an adapter for Auth or some other way of Controller integration. We'll see.

Watch this repo. Write me a message. etc, etc. =) I am open for suggestions.

h3. Contact

"http://twitter.com/m3nt0r":http://twitter.com/m3nt0r
"http://cakealot.com":http://cakealot.com
or at @#cakephp@ on freenode irc

